---
title: "STATS 506 Problem 3"
author: "Lindsey Lin"
format: pdf
editor: visual
---

#### GitHub Repository Link:

```{r package_loading}
library(knitr)
library(haven)
library(tidyverse)
library(broom)
library(pscl)
library(emmeans)
```

## Problem 1

a\. Download the file AUX_I from [this location](https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx?Component=Examination&CycleBeginYear=2015), and determine how to **read it into R**. Then download the file DEMO_I from [this location](http://wwwn.cdc.gov/Nchs/Nhanes/Search/DataPage.aspx?Component=Demographics&CycleBeginYear=2015). Note that each page contains a link to a documentation file for that data set. **Merge the two** files to create a single `data.frame`. **Keep only records which matched**. Print out the **dimensions** of the merged `data.frame`.

```{r data_loading}
audiometry <- as.data.frame(read_xpt("AUX_I.xpt"))
demo <- as.data.frame(read_xpt("DEMO_I.xpt"))
merged_df <- merge(audiometry, demo, by = "SEQN")

dim(merged_df)
```

**Answer**:

Two files merged by `SEQN`, the returned data frame has 4582 rows and 119 columns.

b\. We’ll be using the **following variables.** Clean up each - ensure **all missing values are actually `NA`** (rather than `999` or something), and if it’s categorical, convert it to `factor` with informative `levels`.

-   Gender

-   Citizenship status

-   Number of children 5 years or younger in the household

-   Annual household income - There’s also an issue with the ordering of the categories here; take a look, identify the issue, and implement a solution.

```{r variable_selection_rename}
tymp_demo_df <- merged_df %>% 
  select("SEQN", 
         "tymp_right" = "AUXTWIDR",
         "tymp_left" = "AUXTWIDL",
         "gender" = "RIAGENDR",
         "citizenship" = "DMDCITZN",
         "num_children_5_younger" = "DMDHHSZA",
         "annual_income_code" = "INDHHIN2")

head(tymp_demo_df)
```

```{r variables_cleaning_labeling}
tymp_demo <- tymp_demo_df %>% 
  mutate(
    gender = factor(gender, 
                    levels = c(1, 2), 
                    labels = c("Male", "Female")),
    
    citizenship = case_when(citizenship %in% c(7, 9) ~ NA, 
                            TRUE ~ citizenship),
    
    citizenship = factor(citizenship,
                         levels = c(1, 2),
                         labels = c("U.S. citizen", "Not a citizen")),
    
    annual_income_code = case_when(annual_income_code %in% c(12, 13) ~ NA,
                                   annual_income_code %in% c(77, 99) ~ NA,
                                   TRUE ~ annual_income_code),
    
    annual_income_range = factor(annual_income_code, 
                           ordered = TRUE, 
                           levels = c(1:10, 14, 15),
                           labels = c("$0–4,999", 
                                      "$5,000–9,999",
                                      "$10,000–14,999",
                                      "$15,000–19,999", 
                                      "$20,000–24,999", 
                                      "$25,000–34,999",
                                      "$35,000–44,999",
                                      "$45,000–54,999",
                                      "$55,000–64,999",
                                      "$65,000–74,999",
                                      "$75,000–99,999",
                                      "Over $100,000"))
         )
```

**Answer:**

I selected and renamed the columns needed in this problem, then cleaned and labeled the variables based on the NHANES documentation.

I converted `gender` to factor with 'Male' and 'Female' labels.

For `citizenship`, codes 7 = 'Refused' and 9 = 'Don’t know' were set to `NA`. Then I converted this variable into a factor with 1 = 'U.S. citizen', 2 = 'Not a citizen'.

The original `annual_income_code` is categorical; however, codes 12 = '\$20,000 and over' and 13 = 'Under \$20,000' overlap the detailed ranges, for which they cannot be placed on the same ordered scale as 1–10, 14, 15. Also, 77 = 'Refused' and 99 = 'Don’t know' are non-responses.

So 12, 13, 77, 99 were all set to `NA` to create a meaningful ordered factor. Finally, the remaining detailed bins are labeled and ordered from lowest to highest (I verified the ordering and counts with a frequency table to confirm the levels and the number of `NA`s introduced.)

```{r check_ordering}
fre_table <- as.data.frame(table(tymp_demo$annual_income_range, 
                                 useNA = "ifany"))

names(fre_table) <- c("Income Range", "Count")
kable(fre_table, caption = "Distribution of annual household income")
```

c\. The Tympanometric width measure is looks approximately like a **Poisson distribution**. Fit four Poisson regression models predicting a respondent’s Tympanometric width **in each ear**. Each model is defined below, for a specific ear and a specific set of covariates.

-   1R - Right ear: gender

-   2R - Right ear: gender, citizenship status (as categorical), number of children (as continuous), annual household income (as continuous)

-   1L - Left ear: gender

-   2L - Left ear: gender, citizenship status (as categorical), number of children (as continuous), annual household income (as continuous)

Produce a table presenting the **estimated incidence risk ratios for the coefficients** in each model, along with the **sample size** for the model, the **pseudo-**$R^2$**,** and **AIC** values. (This can be a single table, or one table for coefficients and a separate table for model statistics).

```{r convert_income_continuous}
tymp_demo <- tymp_demo %>% 
  mutate(income_rank = as.integer(annual_income_range))
```

```{r poisson_regression}
m_1R <- glm(tymp_right ~ gender, data = tymp_demo, family = poisson)

m_2R <- glm(tymp_right ~ gender + citizenship + 
                         num_children_5_younger + income_rank,
            data = tymp_demo, family = poisson)

m_1L <- glm(tymp_left ~ gender, data = tymp_demo, family = poisson)

m_2L <- glm(tymp_left ~ gender + citizenship + 
                        num_children_5_younger + income_rank,
            data = tymp_demo, family = poisson)
```

```{r irr_fucntion}
#' irr: compute the estimated incidence risk ratios for the coefficients
#' 
#' This function takes a fitted Poisson regression model and computes the 
#' estimated incidence risk ratios for each coefficient and tags each row 
#' with the model name provided.
#'
#' @param fit A fitted model object 
#' @param model_name A character string giving a name or label for the model.
#' @return A data frame with 3 columns: model, term, and IRR

irr <- function(fit, model_name){
  tidy(fit) %>% 
    mutate(model = model_name,
           IRR = exp(estimate)) %>% 
    select(model, term, IRR)
}
```

```{r incidence_risk_ratios}

rbind(irr(m_1R, "Model 1"), 
      irr(m_2R, "Model 2"), 
      irr(m_1L, "Model 3"), 
      irr(m_2L, "Model 4")) %>% 
  
  filter(term != "(Intercept)") %>% 
  
  mutate(term = recode(
    term,
    "genderFemale" = "Gender: Female",
    "citizenshipNot a citizen" = "Citizenship: Not a citizen",
    "num_children_5_younger" = "Num of children 5 years or younger",
    "income_rank" = "Income rank")) %>% 
  
  pivot_wider(names_from = model, values_from = IRR) %>% 
  
  mutate(across(-term, ~ round(.x, 4))) %>% 
  
  kable(caption = "Incidence Risk Ratios by Models", 
        align = c("l","c","c","c","c"))
```

```{r model_stats_function}
#' model_stats: compute key model statistics
#' 
#' Computes sample size (N), McFadden's pseudo-R², and AIC for a 
#' fitted Poisson regression model
#' 
#' @param model A fitted model object
#' @return A named numeric vector with 3 elements

model_stats <- function(model) {
  return(c(N = length(model$fitted.values),
    R2 = pR2(model)["McFadden"],
    AIC = AIC(model)))
}
```

```{r statistics_glm}
stats_raw <- cbind(model_stats(m_1R),
                   model_stats(m_2R),
                   model_stats(m_1L),
                   model_stats(m_2L))

stats_table <- rbind(formatC(stats_raw[1, ], format = "d"),              
                     formatC(stats_raw[2, ], format = "f", digits = 4),  
                     formatC(stats_raw[3, ], format = "f", digits = 2))

rownames(stats_table) <- c("Sample Size", "Pseudo R²", "AIC")
colnames(stats_table) <- c("Model 1", "Model 2", "Model 3", "Model 4")

kable(stats_table, caption = "Model Statistics")
```

Note:

To treat annual household income as a continuous predictor, I treated the numeric labels of the groups as continuous, for which I converted the ordered income categories to numeric ranks from 1 (lowest) to 12 (highest), using `income_rank = as.integer(annual_income_range)`.

d\. From model 2L, provide evidence whether there is a **difference between males and females** in terms of their incidence risk ratio. **Test whether the predicted value** of Tympanometric width measure of the left ear **differs between men and women**. Include the results of the **each test** and their **interpretation**.

```{r}
summary(m_2L)
```

```{r}
emmeans(m_2L, ~ gender, type = "response")
```

```{r}
pairs(emmeans(m_2L, ~ gender, type = "response"))
```

Answer:

From the summary output of model 2L and Table 2, we can see that the p-value for the gender coefficient is very small, and the IRR is slightly above 1. This provides strong evidence that females differ from males in their expected tympanometric width, after adjusting for other variables. On average, females have about 1.9% higher expected width than males.

To test whether the predicted tympanometric width of the left ear differs between men and women, I used the `emmeans()` function with model 2L. The estimated ratio (male vs. female) of predicted means was 0.982 with a p-value \< 0.0001, indicating that this difference is statistically significant. Therefore, we can conclude that males have significantly lower predicted tympanometric width than females, after adjusting for other variables.
